---
layout: post
title:  The quirky Intel Quark
date:   2022-10-07 19:24:32 +0200
categories: rust intel mcu quark
published: false
---

In 2013 Intel announced the [Quark](https://en.wikipedia.org/wiki/Intel_Quark) processor family. A new low power architecture for embedded and IoT applications. Aimed to compete in a market mostly dominated by ARM. It was not successful, and 2019 Intel discontinued the Quark family.

I cannot recall if I was aware of the Quark products when they where launched. And only recently I started to learn more about these Quark processors. The Quark was never popular, and now that it is deprecated, documentation starts to disappear (or it never existed). So even though the Quark isn't that old, some software archaeology is required.

The Quark family is quite weird. It is based on the pentium ISA, but without hardware floating point support. It inherited all the Intel legacy cruft and boots into 16bit real mode. Some Quark SoCs have an experimental pattern matching peripheral and a secondary DSP core with an alternative non-Intel ISA. Intel even introduced a new ABI for the Quark, the Intel MCU ABI.

While the Quark family only had a short life and is now mostly forgotten, support for it did land in LLVM and lays dormant till this day.

## The Rust revival
Lets try to build some Rust code for a Quark that is using the Intel MCU ABI.

Building Rust code for a non-standard target can be done via a [target.json](https://docs.rust-embedded.org/embedonomicon/custom-target.html) file. It contains a sorts of platform related setting for LLVM, code-gen and linking.

Looking through the [LLVM sources](https://github.com/llvm/llvm-project/blob/0346f78a6f684f602212c457b36f8dbc9e93e3f9/llvm/lib/Support/Triple.cpp#L578) using "elfiamcu" as OS in the target triplet should result in code using the Intel MCU ABI. And the correct data-layout can also be derived from the [source code](https://github.com/llvm/llvm-project/blob/cff5bef948c91e4919de8a5fb9765e0edc13f3de/llvm/lib/Target/X86/X86TargetMachine.cpp#L119).

So I cooked-up a minimal `i586-unknown-elfiamcu.json` and tried to build a test application. Building was successful but linking failed with multiple similar errors, `rust-lld: error: some_file.o is incompatible with /tmp/rustcA1CMNt/symbols.o`.

Why is the linker complaining about incompatibility, and where does this temporary `symbols.o` even come from?





```bash
#!/bin/bash
elfedit --input-mach=i386 --output-mach=IAMCU $3
rust-lld $*
```

`printf '\x06' | dd of=file.elf bs=1 seek=18 count=1 conv=notrunc`

## Generated Assembly
I prepared an example that will show the difference between the calling conventions. I needed to add the `inline(never)` and the empty `asm!()` block to prevent the compiler from inlining and optimizing the call.
```rust
#[no_mangle]
#[inline(never)]
pub extern "C" fn mac(a: i32, b: i32,c: i32) -> i32 {
    unsafe { core::arch::asm!("/* Prevent inter-procedural optimizations */"); }
    a * b + c
}

#[entry]
fn main() -> ! {
    mac(1,2,3);
    loop { }
}
```

The assembly generated by `i586-unknown-elf` uses the `cdecl` calling convention. With this calling convention all argument are pushed to the stack. And the caller is responsible to clean-up the pushed arguments.
```
main:
   0x0018004a <+0>:     push   0x3
   0x0018004c <+2>:     push   0x2
   0x0018004e <+4>:     push   0x1
   0x00180050 <+6>:     call   0x18003c <quark_hello_world::mac>
   0x00180055 <+11>:    add    esp,0xc
   0x00180058 <+14>:    jmp    0x180058 <main+14>

quark_hello_world::mac:
   0x0018003c <+0>:     mov    eax,DWORD PTR [esp+0x8]
   0x00180040 <+4>:     imul   eax,DWORD PTR [esp+0x4]
   0x00180045 <+9>:     add    eax,DWORD PTR [esp+0xc]
   0x00180049 <+13>:    ret
```

The assembly generated by `i586-unknown-elfiamcu` uses the custom calling convention. Where the first three arguments are passed via registers. So in this example the stack is not used at all for arguments, and there is no clean-up code needed.
```
main:
   0x00180042 <+0>:     mov    eax,0x1
   0x00180047 <+5>:     mov    edx,0x2
   0x0018004c <+10>:    mov    ecx,0x3
   0x00180051 <+15>:    call   0x18003c <quark_hello_world::mac>
   0x00180056 <+20>:    jmp    0x180056 <main+20>

quark_hello_world::mac:
   0x0018003c <+0>:     imul   eax,edx
   0x0018003f <+3>:     add    eax,ecx
   0x00180041 <+5>:     ret
```

With this example the IAMCU variant has two instructions less, and the code size is also reduced with two bytes. So IAMCU is technically better in this example. I don't know if there really is a significant difference when the comparison is done with a bigger, real world codebase. But Intel seemed to think it was worth to introduce this alternative calling convention.

## Trivia

### IAMCU, what does it mean?
I never found official documentation that explained the IAMCU abbreviation. And I wondered what is the 'A' in IAMCU? After some googling I found an other abbreviation, IA32 which stands for "Intel Architecture 32-bit". So I think it is safe to assume that IAMCU stands for "Intel Architecture MCU".

### The rename
I wondered why the machine identifier for `EM_IAMCU` was `6`, because this seems remarkable low for this relative recent architecture.
With some googling I found a [Rename EM_486 to EM_IAMCU](https://gcc.gnu.org/legacy-ml/gcc/2015-05/msg00090.html) patch in the GCC mail archive that seems to imply that they picked a value that was reserved for future use.
```diff
 #define EM_88K		  5	/* Motorola m88k family */
-#define EM_486		  6	/* Intel 80486 *//* Reserved for future use */
+#define EM_IAMCU	  6	/* Intel MCU */
 #define EM_860		  7	/* Intel 80860 */
```
But not everybody did the rename. For example [NetBSD](https://github.com/NetBSD/src/blob/trunk/sys/sys/exec_elf.h) has both defines.
```c
#define EM_88K		5	/* Motorola 88000 */
#define EM_486		6	/* Intel 80486 [old] */
#define EM_IAMCU	6	/* Intel MCU. */
#define EM_860		7	/* Intel 80860 */
```

And [Linux](https://elixir.bootlin.com/linux/v6.0/source/include/uapi/linux/elf-em.h#L12) only has `EM_486`.
```c
#define EM_88K		5
#define EM_486		6	/* Perhaps disused */
#define EM_860		7
```

### elfedit
elfedit proofed to be a useful utility to create the hacky linker workaround. I assumed that modifying a ELF header would be a very niche operation, so I didn't expect there to be a utility for it. I still wonder what the normal use-case of elfedit is. What strange things are people doing if elfedit is a part of their build flow?

Google did come up with an other interesting elfedit fact. Solaris also has an [elfedit](https://docs.oracle.com/cd/E36784_01/html/E36870/elfedit-1.html) program. This has a totally different user interface and can practically edit all parts of an ELF file. As expected ELF editing is risky and man page contains the following warning.

> elfedit is designed to be a tool for testing and development of the ELF system. It offers the ability to examine and change nearly every piece of ELF metadata in the object. It quietly allows edits that can produce an invalid or unusable ELF file. The user is expected to have knowledge of the ELF format and of the rules and conventions that govern them.